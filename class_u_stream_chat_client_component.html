<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stream Chat Unreal SDK: UStreamChatClientComponent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Stream Chat Unreal SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_u_stream_chat_client_component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_u_stream_chat_client_component-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">UStreamChatClientComponent Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group___stream_chat.html">Stream Chat</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A component which allows for connecting to the Stream Chat API. Should be added to a client-side actor, e.g. HUD.  
 <a href="class_u_stream_chat_client_component.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_stream_chat_client_component_8h_source.html">StreamChatClientComponent.h</a>&gt;</code></p>

<p>Inherits UActorComponent.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="memItemLeft" align="right" valign="top"><a id="a32bdbcb95a97bb017db3ebc6a5e1cb46" name="a32bdbcb95a97bb017db3ebc6a5e1cb46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UStreamChatClientComponent</b> ()</td></tr>
<tr class="memdesc:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the component. Shouldn't be called directly. <br /></td></tr>
<tr class="separator:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8ee547ffba63c7c799ea57a33dc5d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a8f8ee547ffba63c7c799ea57a33dc5d8">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, TUniquePtr&lt; ITokenProvider &gt; TokenProvider, TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a8f8ee547ffba63c7c799ea57a33dc5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API for the given user and using a custom token provider.  <a href="class_u_stream_chat_client_component.html#a8f8ee547ffba63c7c799ea57a33dc5d8">More...</a><br /></td></tr>
<tr class="separator:a8f8ee547ffba63c7c799ea57a33dc5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1302d9de0292d828254b11da164af157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a1302d9de0292d828254b11da164af157">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const FString &amp;Token, TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a1302d9de0292d828254b11da164af157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API for the given user and credentials.  <a href="class_u_stream_chat_client_component.html#a1302d9de0292d828254b11da164af157">More...</a><br /></td></tr>
<tr class="separator:a1302d9de0292d828254b11da164af157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea82a6a7bf2971427142d5764fbce7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a9ea82a6a7bf2971427142d5764fbce7e">ConnectAnonymousUser</a> (TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a9ea82a6a7bf2971427142d5764fbce7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API anonymously.  <a href="class_u_stream_chat_client_component.html#a9ea82a6a7bf2971427142d5764fbce7e">More...</a><br /></td></tr>
<tr class="separator:a9ea82a6a7bf2971427142d5764fbce7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6779cf5aa87e6d6275f66070033627d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a6779cf5aa87e6d6275f66070033627d1">ConnectGuestUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a6779cf5aa87e6d6275f66070033627d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API by creating a guest account.  <a href="class_u_stream_chat_client_component.html#a6779cf5aa87e6d6275f66070033627d1">More...</a><br /></td></tr>
<tr class="separator:a6779cf5aa87e6d6275f66070033627d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1abed0a192360951268e62a6a78a8e7"><td class="memItemLeft" align="right" valign="top"><a id="ab1abed0a192360951268e62a6a78a8e7" name="ab1abed0a192360951268e62a6a78a8e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DisconnectUser</b> ()</td></tr>
<tr class="memdesc:ab1abed0a192360951268e62a6a78a8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection to the API and resets any state. <br /></td></tr>
<tr class="separator:ab1abed0a192360951268e62a6a78a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6c449d6ed7cbe57df3d390829acedc"><td class="memItemLeft" align="right" valign="top"><a id="a8b6c449d6ed7cbe57df3d390829acedc" name="a8b6c449d6ed7cbe57df3d390829acedc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpsertUsers</b> (const TArray&lt; <a class="el" href="struct_f_user.html">FUser</a> &gt; &amp;Users)</td></tr>
<tr class="memdesc:a8b6c449d6ed7cbe57df3d390829acedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or update one or more users. <br /></td></tr>
<tr class="separator:a8b6c449d6ed7cbe57df3d390829acedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884cc5a41e90df2848ea295dc44270e9"><td class="memItemLeft" align="right" valign="top"><a id="a884cc5a41e90df2848ea295dc44270e9" name="a884cc5a41e90df2848ea295dc44270e9"></a>
<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>NewChat</b> ()</td></tr>
<tr class="memdesc:a884cc5a41e90df2848ea295dc44270e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a null chat channel for starting a new chat/group. <br /></td></tr>
<tr class="separator:a884cc5a41e90df2848ea295dc44270e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe77318f024b6db31d1f2c9771cc463"><td class="memItemLeft" align="right" valign="top"><a id="aebe77318f024b6db31d1f2c9771cc463" name="aebe77318f024b6db31d1f2c9771cc463"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CancelNewChat</b> ()</td></tr>
<tr class="memdesc:aebe77318f024b6db31d1f2c9771cc463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any null chat channels used for starting a new chat/group. <br /></td></tr>
<tr class="separator:aebe77318f024b6db31d1f2c9771cc463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222a25e86b48f7551cc3018df8722698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a222a25e86b48f7551cc3018df8722698">QueryChannels</a> (TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; Filter={}, const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;SortOptions={}, const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a> Flags=<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898a46a2a41cc6e552044816a2d04634545d">EChannelFlags::State</a>|<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898af20658650d987d31063b593c05980397">EChannelFlags::Watch</a>, const <a class="el" href="struct_f_pagination_options.html">FPaginationOptions</a> &amp;PaginationOptions={}, TFunction&lt; void(const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a222a25e86b48f7551cc3018df8722698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the API for all channels which match the given filter. Will also automatically watch all channels.  <a href="class_u_stream_chat_client_component.html#a222a25e86b48f7551cc3018df8722698">More...</a><br /></td></tr>
<tr class="separator:a222a25e86b48f7551cc3018df8722698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a2a8eced83c1c5533f264b8e1c7b5c15e">CreateChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback)</td></tr>
<tr class="memdesc:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions).  <a href="class_u_stream_chat_client_component.html#a2a8eced83c1c5533f264b8e1c7b5c15e">More...</a><br /></td></tr>
<tr class="separator:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b3527835b5c7354ee5eeb8859320a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a705b3527835b5c7354ee5eeb8859320a">WatchChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback)</td></tr>
<tr class="memdesc:a705b3527835b5c7354ee5eeb8859320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates.  <a href="class_u_stream_chat_client_component.html#a705b3527835b5c7354ee5eeb8859320a">More...</a><br /></td></tr>
<tr class="separator:a705b3527835b5c7354ee5eeb8859320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029182849c427dd2d2fe325326042d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a029182849c427dd2d2fe325326042d6c">QueryChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a> Flags, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback={})</td></tr>
<tr class="memdesc:a029182849c427dd2d2fe325326042d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions). Includes options to get data about the channel (including members, watchers and messages), subscribe to future updates.  <a href="class_u_stream_chat_client_component.html#a029182849c427dd2d2fe325326042d6c">More...</a><br /></td></tr>
<tr class="separator:a029182849c427dd2d2fe325326042d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba9ca31b5bd31c24da7bbb63a7cfc73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#adba9ca31b5bd31c24da7bbb63a7cfc73">QueryAdditionalChannels</a> (int32 Limit=10, TFunction&lt; void()&gt; Callback={})</td></tr>
<tr class="memdesc:adba9ca31b5bd31c24da7bbb63a7cfc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch more channels from the server.  <a href="class_u_stream_chat_client_component.html#adba9ca31b5bd31c24da7bbb63a7cfc73">More...</a><br /></td></tr>
<tr class="separator:adba9ca31b5bd31c24da7bbb63a7cfc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbc251fc7fa3f316c8ea609de72727e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#aecbc251fc7fa3f316c8ea609de72727e">QueryUsers</a> (const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;Filter={}, const TArray&lt; <a class="el" href="struct_f_user_sort_option.html">FUserSortOption</a> &gt; &amp;Sort={}, bool bPresence=true, const TOptional&lt; <a class="el" href="struct_f_pagination_options.html">FPaginationOptions</a> &gt; PaginationOptions={}, TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_user_ref.html">FUserRef</a> &gt; &amp;)&gt; Callback={}) const</td></tr>
<tr class="memdesc:aecbc251fc7fa3f316c8ea609de72727e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for users and see if they are online/offline.  <a href="class_u_stream_chat_client_component.html#aecbc251fc7fa3f316c8ea609de72727e">More...</a><br /></td></tr>
<tr class="separator:aecbc251fc7fa3f316c8ea609de72727e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3eda6bd940dbaabba1c5d1a3f33c05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a5f3eda6bd940dbaabba1c5d1a3f33c05">SearchMessages</a> (const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;ChannelFilter={}, const TOptional&lt; FString &gt; &amp;<a class="el" href="group___stream_chat.html#gga5f415eaba7bb8ad8ae40f5b8b3eb69b5a66c1b4c7f3dc385b68a9fa903ccd016d">Query</a>={}, const TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; &amp;MessageFilter={}, const TArray&lt; <a class="el" href="struct_f_message_sort_option.html">FMessageSortOption</a> &gt; &amp;Sort={}, TOptional&lt; uint32 &gt; MessageLimit={}, TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_message.html">FMessage</a> &gt; &amp;)&gt; Callback={}) const</td></tr>
<tr class="memdesc:a5f3eda6bd940dbaabba1c5d1a3f33c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search all messages A channel filter is required. All other parameters are optional, but a minimum of either a query or message filter is additionally required.  <a href="class_u_stream_chat_client_component.html#a5f3eda6bd940dbaabba1c5d1a3f33c05">More...</a><br /></td></tr>
<tr class="separator:a5f3eda6bd940dbaabba1c5d1a3f33c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2012df6e551396792ffb92b3775221"><td class="memItemLeft" align="right" valign="top"><a id="a3c2012df6e551396792ffb92b3775221" name="a3c2012df6e551396792ffb92b3775221"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MarkAllRead</b> () const</td></tr>
<tr class="memdesc:a3c2012df6e551396792ffb92b3775221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all channels as read for the current user. <br /></td></tr>
<tr class="separator:a3c2012df6e551396792ffb92b3775221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f4ebe58908f59fac7872026f37fef"><td class="memItemLeft" align="right" valign="top"><a id="a4f8f4ebe58908f59fac7872026f37fef" name="a4f8f4ebe58908f59fac7872026f37fef"></a>
const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetChannels</b> () const</td></tr>
<tr class="separator:a4f8f4ebe58908f59fac7872026f37fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85afc44dd2f2691a19964721f09bad49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a85afc44dd2f2691a19964721f09bad49">AddDevice</a> (const FString &amp;DeviceId, EPushProvider PushProvider) const</td></tr>
<tr class="memdesc:a85afc44dd2f2691a19964721f09bad49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registering a device associates it with a user and tells the push provider to send new message notifications to the device.  <a href="class_u_stream_chat_client_component.html#a85afc44dd2f2691a19964721f09bad49">More...</a><br /></td></tr>
<tr class="separator:a85afc44dd2f2691a19964721f09bad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f65a566b8ad470d0fd0ac93b7c6da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a31f65a566b8ad470d0fd0ac93b7c6da3">RemoveDevice</a> (const FString &amp;DeviceId) const</td></tr>
<tr class="memdesc:a31f65a566b8ad470d0fd0ac93b7c6da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregistering a device removes the device from the user and stops further new message notifications.  <a href="class_u_stream_chat_client_component.html#a31f65a566b8ad470d0fd0ac93b7c6da3">More...</a><br /></td></tr>
<tr class="separator:a31f65a566b8ad470d0fd0ac93b7c6da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f03f8337f0c164ca3dbcfbc7736a4dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a0f03f8337f0c164ca3dbcfbc7736a4dd">ListDevices</a> (TFunction&lt; void(TArray&lt; <a class="el" href="struct_f_device.html">FDevice</a> &gt;)&gt; Callback) const</td></tr>
<tr class="memdesc:a0f03f8337f0c164ca3dbcfbc7736a4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all available devices.  <a href="class_u_stream_chat_client_component.html#a0f03f8337f0c164ca3dbcfbc7736a4dd">More...</a><br /></td></tr>
<tr class="separator:a0f03f8337f0c164ca3dbcfbc7736a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Blueprint</div></td></tr>
<tr class="memitem:a1447873c496380ce731f51793ca776c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a1447873c496380ce731f51793ca776c1">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const FString &amp;Token, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;OutUser)</td></tr>
<tr class="separator:a1447873c496380ce731f51793ca776c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c61dce47f189b3bc673ec13de9375a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a7c61dce47f189b3bc673ec13de9375a1">ConnectAnonymousUser</a> (const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;OutUser)</td></tr>
<tr class="separator:a7c61dce47f189b3bc673ec13de9375a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0179dda671cc375630b8986ca47ec041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a0179dda671cc375630b8986ca47ec041">ConnectGuestUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;OutUser)</td></tr>
<tr class="separator:a0179dda671cc375630b8986ca47ec041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a960c3c9631c36846e57bf5e183e0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a6a960c3c9631c36846e57bf5e183e0e8">QueryChannels</a> (<a class="el" href="struct_f_filter.html">FFilter</a> Filter, const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;SortOptions, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;OutChannels, UPARAM(meta=(Bitmask, BitmaskEnum=<a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>)) const int32 Flags=3)</td></tr>
<tr class="separator:a6a960c3c9631c36846e57bf5e183e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78cae04fd73d3df82ef147487a5a71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#aa78cae04fd73d3df82ef147487a5a71c">WatchChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="class_u_chat_channel.html">UChatChannel</a> *&amp;OutChannel)</td></tr>
<tr class="separator:aa78cae04fd73d3df82ef147487a5a71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Moderation</div></td></tr>
<tr class="memitem:a486c62c8ef15e1bb6a30e197a38252e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a486c62c8ef15e1bb6a30e197a38252e3">BanUserBP</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, FTimespan Timeout, const FString &amp;Reason, bool bIpBan) const</td></tr>
<tr class="memdesc:a486c62c8ef15e1bb6a30e197a38252e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ban a user from app entirely When a user is banned, they will not be allowed to post messages until the ban is removed or expired but will be able to connect to Chat and to channels as before.  <a href="class_u_stream_chat_client_component.html#a486c62c8ef15e1bb6a30e197a38252e3">More...</a><br /></td></tr>
<tr class="separator:a486c62c8ef15e1bb6a30e197a38252e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aff5e44d76ebbe56083a37c22af3a8"><td class="memItemLeft" align="right" valign="top"><a id="a72aff5e44d76ebbe56083a37c22af3a8" name="a72aff5e44d76ebbe56083a37c22af3a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BanUser</b> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, const TOptional&lt; FTimespan &gt; &amp;Timeout={}, const TOptional&lt; FString &gt; &amp;Reason={}, bool bIpBan=false) const</td></tr>
<tr class="separator:a72aff5e44d76ebbe56083a37c22af3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f007e47d4a929205530d6f1532987c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a81f007e47d4a929205530d6f1532987c">UnbanUser</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User) const</td></tr>
<tr class="memdesc:a81f007e47d4a929205530d6f1532987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove previously applied app-wide ban.  <a href="class_u_stream_chat_client_component.html#a81f007e47d4a929205530d6f1532987c">More...</a><br /></td></tr>
<tr class="separator:a81f007e47d4a929205530d6f1532987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0af8f1229eae083620447a715ce5b78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#ac0af8f1229eae083620447a715ce5b78">ShadowBanUserBP</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, FTimespan Timeout) const</td></tr>
<tr class="memdesc:ac0af8f1229eae083620447a715ce5b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow ban a user from app entirely When a user is banned, they will not be allowed to post messages until the ban is removed or expired but will be able to connect to Chat and to channels as before.  <a href="class_u_stream_chat_client_component.html#ac0af8f1229eae083620447a715ce5b78">More...</a><br /></td></tr>
<tr class="separator:ac0af8f1229eae083620447a715ce5b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106ee531def122fa55adfe53009983b0"><td class="memItemLeft" align="right" valign="top"><a id="a106ee531def122fa55adfe53009983b0" name="a106ee531def122fa55adfe53009983b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ShadowBanUser</b> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, const TOptional&lt; FTimespan &gt; &amp;Timeout={}) const</td></tr>
<tr class="separator:a106ee531def122fa55adfe53009983b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136da36f3a2a1d55a490813affefd32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a136da36f3a2a1d55a490813affefd32f">ShadowUnbanUser</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User) const</td></tr>
<tr class="memdesc:a136da36f3a2a1d55a490813affefd32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove previously applied app-wide shadow ban.  <a href="class_u_stream_chat_client_component.html#a136da36f3a2a1d55a490813affefd32f">More...</a><br /></td></tr>
<tr class="separator:a136da36f3a2a1d55a490813affefd32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddd4f30443b462afb6e9696dc4d4c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a6ddd4f30443b462afb6e9696dc4d4c69">QueryBannedUsers</a> (const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;Filter, const TArray&lt; <a class="el" href="struct_f_ban_sort_option.html">FBanSortOption</a> &gt; &amp;SortOptions={}, const TOptional&lt; <a class="el" href="struct_f_ban_pagination_options.html">FBanPaginationOptions</a> &gt; PaginationOptions={}, const TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_ban.html">FBan</a> &gt; &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a6ddd4f30443b462afb6e9696dc4d4c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and filter channel-scoped or global user bans.  <a href="class_u_stream_chat_client_component.html#a6ddd4f30443b462afb6e9696dc4d4c69">More...</a><br /></td></tr>
<tr class="separator:a6ddd4f30443b462afb6e9696dc4d4c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8287ec7584239e4209ef2ec260ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a52d8287ec7584239e4209ef2ec260ea8">FlagMessage</a> (const <a class="el" href="struct_f_message.html">FMessage</a> &amp;Message) const</td></tr>
<tr class="memdesc:a52d8287ec7584239e4209ef2ec260ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag message for moderation.  <a href="class_u_stream_chat_client_component.html#a52d8287ec7584239e4209ef2ec260ea8">More...</a><br /></td></tr>
<tr class="separator:a52d8287ec7584239e4209ef2ec260ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345b12be807a2217147d3e37ef9b311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a5345b12be807a2217147d3e37ef9b311">FlagUser</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User) const</td></tr>
<tr class="memdesc:a5345b12be807a2217147d3e37ef9b311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag user for moderation.  <a href="class_u_stream_chat_client_component.html#a5345b12be807a2217147d3e37ef9b311">More...</a><br /></td></tr>
<tr class="separator:a5345b12be807a2217147d3e37ef9b311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b35b743dca85a1e73fceaabdcada3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a47b35b743dca85a1e73fceaabdcada3d">MuteUserBP</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, FTimespan Timeout) const</td></tr>
<tr class="memdesc:a47b35b743dca85a1e73fceaabdcada3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mute the given user.  <a href="class_u_stream_chat_client_component.html#a47b35b743dca85a1e73fceaabdcada3d">More...</a><br /></td></tr>
<tr class="separator:a47b35b743dca85a1e73fceaabdcada3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36f6a0c1b84100f349f44fce95a6e96"><td class="memItemLeft" align="right" valign="top"><a id="af36f6a0c1b84100f349f44fce95a6e96" name="af36f6a0c1b84100f349f44fce95a6e96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MuteUser</b> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User, const TOptional&lt; FTimespan &gt; &amp;Timeout={}) const</td></tr>
<tr class="separator:af36f6a0c1b84100f349f44fce95a6e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b0b86d6b374c18ea9f580060805773"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a40b0b86d6b374c18ea9f580060805773">UnmuteUser</a> (const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;User) const</td></tr>
<tr class="memdesc:a40b0b86d6b374c18ea9f580060805773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmute a previously muted user.  <a href="class_u_stream_chat_client_component.html#a40b0b86d6b374c18ea9f580060805773">More...</a><br /></td></tr>
<tr class="separator:a40b0b86d6b374c18ea9f580060805773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f1611110a0cfab519e76f15b13cdb66"><td class="memItemLeft" align="right" valign="top"><a id="a8f1611110a0cfab519e76f15b13cdb66" name="a8f1611110a0cfab519e76f15b13cdb66"></a>
static FString&#160;</td><td class="memItemRight" valign="bottom"><b>DevToken</b> (const FString &amp;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8fa4733e94f511132be01e92cc23c017d16">UserId</a>)</td></tr>
<tr class="separator:a8f1611110a0cfab519e76f15b13cdb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af011c46e90b9370774d1339f605463a6"><td class="memItemLeft" align="right" valign="top"><a id="af011c46e90b9370774d1339f605463a6" name="af011c46e90b9370774d1339f605463a6"></a>
FString&#160;</td><td class="memItemRight" valign="bottom"><b>ApiKey</b></td></tr>
<tr class="separator:af011c46e90b9370774d1339f605463a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="memItemLeft" align="right" valign="top"><a id="a4782f198e76dd5dbd7ab4300eacfc9e8" name="a4782f198e76dd5dbd7ab4300eacfc9e8"></a>
FChannelsUpdatedDelegate&#160;</td><td class="memItemRight" valign="bottom"><b>ChannelsUpdated</b></td></tr>
<tr class="memdesc:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired when any of the channels we have locally change. <br /></td></tr>
<tr class="separator:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Events</h2></td></tr>
<tr class="memitem:aeaac251987fde4f7b63336a7395a307b"><td class="memTemplParams" colspan="2"><a id="aeaac251987fde4f7b63336a7395a307b" name="aeaac251987fde4f7b63336a7395a307b"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:aeaac251987fde4f7b63336a7395a307b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventMulticastDelegate</b> = TMulticastDelegate&lt; void(const TEvent &amp;Event)&gt;</td></tr>
<tr class="separator:aeaac251987fde4f7b63336a7395a307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e75d25f54e9e4c99a05e7caabe452"><td class="memTemplParams" colspan="2"><a id="a653e75d25f54e9e4c99a05e7caabe452" name="a653e75d25f54e9e4c99a05e7caabe452"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:a653e75d25f54e9e4c99a05e7caabe452"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegate</b> = typename TEventMulticastDelegate&lt; TEvent &gt;::FDelegate</td></tr>
<tr class="separator:a653e75d25f54e9e4c99a05e7caabe452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memTemplParams" colspan="2"><a id="a2d3d87a8196b5b1e53a6f1bb02a7547d" name="a2d3d87a8196b5b1e53a6f1bb02a7547d"></a>
template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegateUObjectMethodPtr</b> = typename TEventDelegate&lt; TEvent &gt;::template TUObjectMethodDelegate&lt; UserClass &gt;::FMethodPtr</td></tr>
<tr class="separator:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec955f99d115672ad46f86b82690c9f"><td class="memTemplParams" colspan="2"><a id="a4ec955f99d115672ad46f86b82690c9f" name="a4ec955f99d115672ad46f86b82690c9f"></a>
template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a4ec955f99d115672ad46f86b82690c9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegateSpMethodPtr</b> = typename TEventDelegate&lt; TEvent &gt;::template TSPMethodDelegate&lt; UserClass &gt;::FMethodPtr</td></tr>
<tr class="separator:a4ec955f99d115672ad46f86b82690c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa7f538db03c650b73e9ac381eb15b"><td class="memTemplParams" colspan="2"><a id="a8faa7f538db03c650b73e9ac381eb15b" name="a8faa7f538db03c650b73e9ac381eb15b"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:a8faa7f538db03c650b73e9ac381eb15b"><td class="memTemplItemLeft" align="right" valign="top">FDelegateHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><b>On</b> (TEventDelegate&lt; TEvent &gt; Callback)</td></tr>
<tr class="memdesc:a8faa7f538db03c650b73e9ac381eb15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to a client event using your own delegate object. <br /></td></tr>
<tr class="separator:a8faa7f538db03c650b73e9ac381eb15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03464a6c70a6848cff3e0744099a7a86"><td class="memTemplParams" colspan="2">template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a03464a6c70a6848cff3e0744099a7a86"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt; TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a03464a6c70a6848cff3e0744099a7a86">On</a> (UserClass *Obj, TEventDelegateUObjectMethodPtr&lt; TEvent, UserClass &gt; Method)</td></tr>
<tr class="separator:a03464a6c70a6848cff3e0744099a7a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c33fda79441595223429c1e769e320f"><td class="memTemplParams" colspan="2">template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a0c33fda79441595223429c1e769e320f"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt;!TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a0c33fda79441595223429c1e769e320f">On</a> (UserClass *Obj, TEventDelegateSpMethodPtr&lt; TEvent, UserClass &gt; Method)</td></tr>
<tr class="separator:a0c33fda79441595223429c1e769e320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d38cc193bb913b0aa09b8269e6bbe4b"><td class="memTemplParams" colspan="2">template&lt;class TEvent , typename FunctorType , typename... VarTypes&gt; </td></tr>
<tr class="memitem:a7d38cc193bb913b0aa09b8269e6bbe4b"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt; TIsInvocable&lt; FunctorType, constTEvent &amp;, VarTypes... &gt;::Value, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a7d38cc193bb913b0aa09b8269e6bbe4b">On</a> (FunctorType &amp;&amp;Functor, VarTypes... Vars)</td></tr>
<tr class="separator:a7d38cc193bb913b0aa09b8269e6bbe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memTemplParams" colspan="2"><a id="aef6c08642d4ed10c3c0de4dfba355e55" name="aef6c08642d4ed10c3c0de4dfba355e55"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Unsubscribe</b> (FDelegateHandle) const</td></tr>
<tr class="separator:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A component which allows for connecting to the Stream Chat API. Should be added to a client-side actor, e.g. HUD. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a85afc44dd2f2691a19964721f09bad49" name="a85afc44dd2f2691a19964721f09bad49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85afc44dd2f2691a19964721f09bad49">&#9670;&nbsp;</a></span>AddDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::AddDevice </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>DeviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPushProvider&#160;</td>
          <td class="paramname"><em>PushProvider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registering a device associates it with a user and tells the push provider to send new message notifications to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>Device-specific identifier </td></tr>
    <tr><td class="paramname">PushProvider</td><td>Which provider to use for push notifications </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486c62c8ef15e1bb6a30e197a38252e3" name="a486c62c8ef15e1bb6a30e197a38252e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486c62c8ef15e1bb6a30e197a38252e3">&#9670;&nbsp;</a></span>BanUserBP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::BanUserBP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FTimespan&#160;</td>
          <td class="paramname"><em>Timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>Reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIpBan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ban a user from app entirely When a user is banned, they will not be allowed to post messages until the ban is removed or expired but will be able to connect to Chat and to channels as before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>User to ban </td></tr>
    <tr><td class="paramname">Timeout</td><td>Timeout of ban. User will be unbanned after this period of time (unlimited if zero) </td></tr>
    <tr><td class="paramname">Reason</td><td>Ban reason (optional) </td></tr>
    <tr><td class="paramname">bIpBan</td><td>Whether to perform IP ban or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c61dce47f189b3bc673ec13de9375a1" name="a7c61dce47f189b3bc673ec13de9375a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c61dce47f189b3bc673ec13de9375a1">&#9670;&nbsp;</a></span>ConnectAnonymousUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectAnonymousUser </td>
          <td>(</td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a connection to the API anonymously </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutUser</td><td>Anonymous user info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea82a6a7bf2971427142d5764fbce7e" name="a9ea82a6a7bf2971427142d5764fbce7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea82a6a7bf2971427142d5764fbce7e">&#9670;&nbsp;</a></span>ConnectAnonymousUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectAnonymousUser </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API anonymously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anonymous user info </dd></dl>

</div>
</div>
<a id="a0179dda671cc375630b8986ca47ec041" name="a0179dda671cc375630b8986ca47ec041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0179dda671cc375630b8986ca47ec041">&#9670;&nbsp;</a></span>ConnectGuestUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectGuestUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a connection to the API by creating a guest account </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">OutUser</td><td>Guest user info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6779cf5aa87e6d6275f66070033627d1" name="a6779cf5aa87e6d6275f66070033627d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6779cf5aa87e6d6275f66070033627d1">&#9670;&nbsp;</a></span>ConnectGuestUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectGuestUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API by creating a guest account. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anonymous user info </dd></dl>

</div>
</div>
<a id="a1447873c496380ce731f51793ca776c1" name="a1447873c496380ce731f51793ca776c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1447873c496380ce731f51793ca776c1">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>Token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a connection to the API for the given user and credentials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Token</td><td>A JWT token for the given user </td></tr>
    <tr><td class="paramname">OutUser</td><td>Latest info of the logged in user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1302d9de0292d828254b11da164af157" name="a1302d9de0292d828254b11da164af157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1302d9de0292d828254b11da164af157">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>Token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API for the given user and credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Token</td><td>A JWT token for the given user </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Latest info if the logged in user </dd></dl>

</div>
</div>
<a id="a8f8ee547ffba63c7c799ea57a33dc5d8" name="a8f8ee547ffba63c7c799ea57a33dc5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8ee547ffba63c7c799ea57a33dc5d8">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUniquePtr&lt; ITokenProvider &gt;&#160;</td>
          <td class="paramname"><em>TokenProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_own_user.html">FOwnUser</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API for the given user and using a custom token provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">TokenProvider</td><td>Can be used to asynchronously generate tokens from your own backend </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Latest info if the logged in user </dd></dl>

</div>
</div>
<a id="a2a8eced83c1c5533f264b8e1c7b5c15e" name="a2a8eced83c1c5533f264b8e1c7b5c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8eced83c1c5533f264b8e1c7b5c15e">&#9670;&nbsp;</a></span>CreateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::CreateChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to create </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<a id="a52d8287ec7584239e4209ef2ec260ea8" name="a52d8287ec7584239e4209ef2ec260ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d8287ec7584239e4209ef2ec260ea8">&#9670;&nbsp;</a></span>FlagMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::FlagMessage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_message.html">FMessage</a> &amp;&#160;</td>
          <td class="paramname"><em>Message</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag message for moderation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Message</td><td>A reference to an existing message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5345b12be807a2217147d3e37ef9b311" name="a5345b12be807a2217147d3e37ef9b311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5345b12be807a2217147d3e37ef9b311">&#9670;&nbsp;</a></span>FlagUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::FlagUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag user for moderation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>A reference to a user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f03f8337f0c164ca3dbcfbc7736a4dd" name="a0f03f8337f0c164ca3dbcfbc7736a4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f03f8337f0c164ca3dbcfbc7736a4dd">&#9670;&nbsp;</a></span>ListDevices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ListDevices </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(TArray&lt; <a class="el" href="struct_f_device.html">FDevice</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all available devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when response is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47b35b743dca85a1e73fceaabdcada3d" name="a47b35b743dca85a1e73fceaabdcada3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b35b743dca85a1e73fceaabdcada3d">&#9670;&nbsp;</a></span>MuteUserBP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::MuteUserBP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FTimespan&#160;</td>
          <td class="paramname"><em>Timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mute the given user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Timeout</td><td>Timeout of ban. User will be unbanned after this period of time (unlimited if zero)</td></tr>
    <tr><td class="paramname">User</td><td>A reference to a user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d38cc193bb913b0aa09b8269e6bbe4b" name="a7d38cc193bb913b0aa09b8269e6bbe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d38cc193bb913b0aa09b8269e6bbe4b">&#9670;&nbsp;</a></span>On() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , typename FunctorType , typename... VarTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt; TIsInvocable&lt; FunctorType, constTEvent &amp;, VarTypes... &gt;::Value, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">FunctorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>Functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarTypes...&#160;</td>
          <td class="paramname"><em>Vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Subscribe to a client event using a C++ lambda </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Functor</td><td>Lambda to execute when event occurs. Should have signature similar to: [](const TEvent&amp; Event){} </td></tr>
    <tr><td class="paramname">Vars</td><td>Additional variables to pass to the lambda </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="a0c33fda79441595223429c1e769e320f" name="a0c33fda79441595223429c1e769e320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c33fda79441595223429c1e769e320f">&#9670;&nbsp;</a></span>On() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , class UserClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt;!TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">UserClass *&#160;</td>
          <td class="paramname"><em>Obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEventDelegateSpMethodPtr&lt; TEvent, UserClass &gt;&#160;</td>
          <td class="paramname"><em>Method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Subscribe to a client event using a shared pointer-based (fast, not thread-safe) member function delegate. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td>Object with given method </td></tr>
    <tr><td class="paramname">Method</td><td>Method to call when event occurs. Should have signature: void OnMyEvent(const TEvent&amp; Event) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="a03464a6c70a6848cff3e0744099a7a86" name="a03464a6c70a6848cff3e0744099a7a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03464a6c70a6848cff3e0744099a7a86">&#9670;&nbsp;</a></span>On() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , class UserClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt; TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">::Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">UserClass *&#160;</td>
          <td class="paramname"><em>Obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEventDelegateUObjectMethodPtr&lt; TEvent, UserClass &gt;&#160;</td>
          <td class="paramname"><em>Method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Subscribe to a client event using a UObject-based member function delegate. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td>UObject with given method </td></tr>
    <tr><td class="paramname">Method</td><td>Method to call when event occurs. Should have signature: void OnMyEvent(const TEvent&amp; Event) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="adba9ca31b5bd31c24da7bbb63a7cfc73" name="adba9ca31b5bd31c24da7bbb63a7cfc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba9ca31b5bd31c24da7bbb63a7cfc73">&#9670;&nbsp;</a></span>QueryAdditionalChannels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryAdditionalChannels </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>Limit</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch more channels from the server. </p>
<dl class="section attention"><dt>Attention</dt><dd>Some messages must already have been fetched for this to do anything. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Limit</td><td>Number of channels returned is limited by this value. Maximum 30. </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the backend </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ddd4f30443b462afb6e9696dc4d4c69" name="a6ddd4f30443b462afb6e9696dc4d4c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddd4f30443b462afb6e9696dc4d4c69">&#9670;&nbsp;</a></span>QueryBannedUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryBannedUsers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>Filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_ban_sort_option.html">FBanSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; <a class="el" href="struct_f_ban_pagination_options.html">FBanPaginationOptions</a> &gt;&#160;</td>
          <td class="paramname"><em>PaginationOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_ban.html">FBan</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find and filter channel-scoped or global user bans. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://getstream.io/chat/docs/unreal/moderation/#query-bans-endpoint">https://getstream.io/chat/docs/unreal/moderation/#query-bans-endpoint</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>Conditions to use to filter the banned users </td></tr>
    <tr><td class="paramname">SortOptions</td><td>The sorting used for the banned users matching the filters. Sorting is based on field and direction, multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">PaginationOptions</td><td>Pagination for bans can be done in two ways: using offset/limit or using the "created_at" field. </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when response is received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a029182849c427dd2d2fe325326042d6c" name="a029182849c427dd2d2fe325326042d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029182849c427dd2d2fe325326042d6c">&#9670;&nbsp;</a></span>QueryChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions). Includes options to get data about the channel (including members, watchers and messages), subscribe to future updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to query </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<a id="a6a960c3c9631c36846e57bf5e183e0e8" name="a6a960c3c9631c36846e57bf5e183e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a960c3c9631c36846e57bf5e183e0e8">&#9670;&nbsp;</a></span>QueryChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_filter.html">FFilter</a>&#160;</td>
          <td class="paramname"><em>Filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UPARAM(meta=(Bitmask, BitmaskEnum=<a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>)) const int32&#160;</td>
          <td class="paramname"><em>Flags</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the API for all channels which match the given filter. Will also automatically watch all channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>The query filters to use. You can query on any of the custom fields you've defined on the Channel. As a minimum, the filter should be something like: { members: { $in: [userID] } } </td></tr>
    <tr><td class="paramname">SortOptions</td><td>The sorting used for the channels matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">OutChannels</td><td>An array of channel objects which can be used to interact with the channels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a222a25e86b48f7551cc3018df8722698" name="a222a25e86b48f7551cc3018df8722698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222a25e86b48f7551cc3018df8722698">&#9670;&nbsp;</a></span>QueryChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannels </td>
          <td>(</td>
          <td class="paramtype">TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt;&#160;</td>
          <td class="paramname"><em>Filter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>&#160;</td>
          <td class="paramname"><em>Flags</em> = <code><a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898a46a2a41cc6e552044816a2d04634545d">EChannelFlags::State</a>&#160;|&#160;<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898af20658650d987d31063b593c05980397">EChannelFlags::Watch</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_pagination_options.html">FPaginationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>PaginationOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the API for all channels which match the given filter. Will also automatically watch all channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
    <tr><td class="paramname">Filter</td><td>The query filters to use. You can query on any of the custom fields you've defined on the Channel. As a minimum, the filter should be something like: { members: { $in: [userID] } } </td></tr>
    <tr><td class="paramname">SortOptions</td><td>The sorting used for the channels matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">PaginationOptions</td><td>Pagination offset and limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of channel objects which can be used to interact with the channels </dd></dl>

</div>
</div>
<a id="aecbc251fc7fa3f316c8ea609de72727e" name="aecbc251fc7fa3f316c8ea609de72727e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbc251fc7fa3f316c8ea609de72727e">&#9670;&nbsp;</a></span>QueryUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryUsers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>Filter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_user_sort_option.html">FUserSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sort</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPresence</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; <a class="el" href="struct_f_pagination_options.html">FPaginationOptions</a> &gt;&#160;</td>
          <td class="paramname"><em>PaginationOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_user_ref.html">FUserRef</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for users and see if they are online/offline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bPresence</td><td>Get updates when the user goes offline/online </td></tr>
    <tr><td class="paramname">Filter</td><td>Conditions to use to filter the users, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://getstream.io/chat/docs/unreal/query_users">https://getstream.io/chat/docs/unreal/query_users</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sort</td><td>The sorting used for the users matching the filters. Sorting is based on field and direction, multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">PaginationOptions</td><td>The number of users to return and pagination offset </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when response is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31f65a566b8ad470d0fd0ac93b7c6da3" name="a31f65a566b8ad470d0fd0ac93b7c6da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f65a566b8ad470d0fd0ac93b7c6da3">&#9670;&nbsp;</a></span>RemoveDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::RemoveDevice </td>
          <td>(</td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>DeviceId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregistering a device removes the device from the user and stops further new message notifications. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceId</td><td>Device-specific identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f3eda6bd940dbaabba1c5d1a3f33c05" name="a5f3eda6bd940dbaabba1c5d1a3f33c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3eda6bd940dbaabba1c5d1a3f33c05">&#9670;&nbsp;</a></span>SearchMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::SearchMessages </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelFilter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>Query</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>MessageFilter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_message_sort_option.html">FMessageSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sort</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOptional&lt; uint32 &gt;&#160;</td>
          <td class="paramname"><em>MessageLimit</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_message.html">FMessage</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search all messages A channel filter is required. All other parameters are optional, but a minimum of either a query or message filter is additionally required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when response is received </td></tr>
    <tr><td class="paramname">Query</td><td>Search phrase </td></tr>
    <tr><td class="paramname">ChannelFilter</td><td>Channel filter conditions </td></tr>
    <tr><td class="paramname">MessageFilter</td><td>Message filter conditions </td></tr>
    <tr><td class="paramname">Sort</td><td>Sort parameters. Cannot be used with non-zero offset. </td></tr>
    <tr><td class="paramname">MessageLimit</td><td>Number of messages to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0af8f1229eae083620447a715ce5b78" name="ac0af8f1229eae083620447a715ce5b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0af8f1229eae083620447a715ce5b78">&#9670;&nbsp;</a></span>ShadowBanUserBP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ShadowBanUserBP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FTimespan&#160;</td>
          <td class="paramname"><em>Timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow ban a user from app entirely When a user is banned, they will not be allowed to post messages until the ban is removed or expired but will be able to connect to Chat and to channels as before. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>User to ban </td></tr>
    <tr><td class="paramname">Timeout</td><td>Timeout of ban. User will be unbanned after this period of time (unlimited if zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a136da36f3a2a1d55a490813affefd32f" name="a136da36f3a2a1d55a490813affefd32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a136da36f3a2a1d55a490813affefd32f">&#9670;&nbsp;</a></span>ShadowUnbanUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ShadowUnbanUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove previously applied app-wide shadow ban. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>User to unban </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81f007e47d4a929205530d6f1532987c" name="a81f007e47d4a929205530d6f1532987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81f007e47d4a929205530d6f1532987c">&#9670;&nbsp;</a></span>UnbanUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::UnbanUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove previously applied app-wide ban. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>User to unban </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40b0b86d6b374c18ea9f580060805773" name="a40b0b86d6b374c18ea9f580060805773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b0b86d6b374c18ea9f580060805773">&#9670;&nbsp;</a></span>UnmuteUser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::UnmuteUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmute a previously muted user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>A reference to a user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa78cae04fd73d3df82ef147487a5a71c" name="aa78cae04fd73d3df82ef147487a5a71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78cae04fd73d3df82ef147487a5a71c">&#9670;&nbsp;</a></span>WatchChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::WatchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_u_chat_channel.html">UChatChannel</a> *&amp;&#160;</td>
          <td class="paramname"><em>OutChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to watch </td></tr>
    <tr><td class="paramname">OutChannel</td><td>Object which can be used to interact with the channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a705b3527835b5c7354ee5eeb8859320a" name="a705b3527835b5c7354ee5eeb8859320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b3527835b5c7354ee5eeb8859320a">&#9670;&nbsp;</a></span>WatchChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::WatchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to watch </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/StreamChat/Public/<a class="el" href="_stream_chat_client_component_8h_source.html">StreamChatClientComponent.h</a></li>
<li>Source/StreamChat/Private/StreamChatClientComponent.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_u_stream_chat_client_component.html">UStreamChatClientComponent</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
