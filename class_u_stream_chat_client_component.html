<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stream Chat Unreal SDK: UStreamChatClientComponent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Stream Chat Unreal SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_u_stream_chat_client_component.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_u_stream_chat_client_component-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UStreamChatClientComponent Class Reference<span class="mlabels"><span class="mlabel">final</span></span><div class="ingroups"><a class="el" href="group___stream_chat.html">Stream Chat</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A component which allows for connecting to the Stream Chat API. Should be added to a client-side actor, e.g. HUD.  
 <a href="class_u_stream_chat_client_component.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_stream_chat_client_component_8h_source.html">StreamChatClientComponent.h</a>&gt;</code></p>

<p>Inherits UActorComponent.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aeaac251987fde4f7b63336a7395a307b"><td class="memTemplParams" colspan="2"><a id="aeaac251987fde4f7b63336a7395a307b"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:aeaac251987fde4f7b63336a7395a307b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventMulticastDelegate</b> = TMulticastDelegate&lt; void(const TEvent &amp;Event)&gt;</td></tr>
<tr class="separator:aeaac251987fde4f7b63336a7395a307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e75d25f54e9e4c99a05e7caabe452"><td class="memTemplParams" colspan="2"><a id="a653e75d25f54e9e4c99a05e7caabe452"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:a653e75d25f54e9e4c99a05e7caabe452"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegate</b> = typename TEventMulticastDelegate&lt; TEvent &gt;::FDelegate</td></tr>
<tr class="separator:a653e75d25f54e9e4c99a05e7caabe452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memTemplParams" colspan="2"><a id="a2d3d87a8196b5b1e53a6f1bb02a7547d"></a>
template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegateUObjectMethodPtr</b> = typename TEventDelegate&lt; TEvent &gt;::template TUObjectMethodDelegate&lt; UserClass &gt;::FMethodPtr</td></tr>
<tr class="separator:a2d3d87a8196b5b1e53a6f1bb02a7547d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec955f99d115672ad46f86b82690c9f"><td class="memTemplParams" colspan="2"><a id="a4ec955f99d115672ad46f86b82690c9f"></a>
template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a4ec955f99d115672ad46f86b82690c9f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TEventDelegateSpMethodPtr</b> = typename TEventDelegate&lt; TEvent &gt;::template TSPMethodDelegate&lt; UserClass &gt;::FMethodPtr</td></tr>
<tr class="separator:a4ec955f99d115672ad46f86b82690c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="memItemLeft" align="right" valign="top"><a id="a32bdbcb95a97bb017db3ebc6a5e1cb46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a32bdbcb95a97bb017db3ebc6a5e1cb46">UStreamChatClientComponent</a> ()</td></tr>
<tr class="memdesc:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the component. Shouldn't be called directly. <br /></td></tr>
<tr class="separator:a32bdbcb95a97bb017db3ebc6a5e1cb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772775375b6df48ed9280caa356dea13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a772775375b6df48ed9280caa356dea13">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, TUniquePtr&lt; ITokenProvider &gt; TokenProvider, TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a772775375b6df48ed9280caa356dea13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API for the given user and using a custom token provider.  <a href="class_u_stream_chat_client_component.html#a772775375b6df48ed9280caa356dea13">More...</a><br /></td></tr>
<tr class="separator:a772775375b6df48ed9280caa356dea13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6229a8fcf989852a5abc72c04779b58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#ac6229a8fcf989852a5abc72c04779b58">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const FString &amp;Token, TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:ac6229a8fcf989852a5abc72c04779b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API for the given user and credentials.  <a href="class_u_stream_chat_client_component.html#ac6229a8fcf989852a5abc72c04779b58">More...</a><br /></td></tr>
<tr class="separator:ac6229a8fcf989852a5abc72c04779b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137af7f2bf4a48b1a0c1e75e04d2af3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a137af7f2bf4a48b1a0c1e75e04d2af3c">ConnectAnonymousUser</a> (TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:a137af7f2bf4a48b1a0c1e75e04d2af3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API anonymously.  <a href="class_u_stream_chat_client_component.html#a137af7f2bf4a48b1a0c1e75e04d2af3c">More...</a><br /></td></tr>
<tr class="separator:a137af7f2bf4a48b1a0c1e75e04d2af3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2bbdb1a7df673dbaecfd8e8c28d6fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#ac2bbdb1a7df673dbaecfd8e8c28d6fc3">ConnectGuestUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt; Callback={})</td></tr>
<tr class="memdesc:ac2bbdb1a7df673dbaecfd8e8c28d6fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a connection to the API by creating a guest account.  <a href="class_u_stream_chat_client_component.html#ac2bbdb1a7df673dbaecfd8e8c28d6fc3">More...</a><br /></td></tr>
<tr class="separator:ac2bbdb1a7df673dbaecfd8e8c28d6fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1abed0a192360951268e62a6a78a8e7"><td class="memItemLeft" align="right" valign="top"><a id="ab1abed0a192360951268e62a6a78a8e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#ab1abed0a192360951268e62a6a78a8e7">DisconnectUser</a> ()</td></tr>
<tr class="memdesc:ab1abed0a192360951268e62a6a78a8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the connection to the API and resets any state. <br /></td></tr>
<tr class="separator:ab1abed0a192360951268e62a6a78a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70109502de94907851f19ae97fe02a8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a70109502de94907851f19ae97fe02a8b">QueryChannels</a> (TFunction&lt; void(const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;)&gt; Callback, TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; Filter={}, const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;SortOptions={}, const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a> Flags=<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898a46a2a41cc6e552044816a2d04634545d">EChannelFlags::State</a>|<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898af20658650d987d31063b593c05980397">EChannelFlags::Watch</a>, const <a class="el" href="struct_f_channel_pagination_options.html">FChannelPaginationOptions</a> &amp;PaginationOptions={})</td></tr>
<tr class="memdesc:a70109502de94907851f19ae97fe02a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the API for all channels which match the given filter. Will also automatically watch all channels.  <a href="class_u_stream_chat_client_component.html#a70109502de94907851f19ae97fe02a8b">More...</a><br /></td></tr>
<tr class="separator:a70109502de94907851f19ae97fe02a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a2a8eced83c1c5533f264b8e1c7b5c15e">CreateChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback)</td></tr>
<tr class="memdesc:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions).  <a href="class_u_stream_chat_client_component.html#a2a8eced83c1c5533f264b8e1c7b5c15e">More...</a><br /></td></tr>
<tr class="separator:a2a8eced83c1c5533f264b8e1c7b5c15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b3527835b5c7354ee5eeb8859320a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a705b3527835b5c7354ee5eeb8859320a">WatchChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback)</td></tr>
<tr class="memdesc:a705b3527835b5c7354ee5eeb8859320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates.  <a href="class_u_stream_chat_client_component.html#a705b3527835b5c7354ee5eeb8859320a">More...</a><br /></td></tr>
<tr class="separator:a705b3527835b5c7354ee5eeb8859320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d324df894080737f8e915db575fed6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a4d324df894080737f8e915db575fed6d">QueryChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a> Flags, TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt; Callback)</td></tr>
<tr class="memdesc:a4d324df894080737f8e915db575fed6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a channel if it does not exist yet (if this user has the right permissions). Includes options to get data about the channel (including members, watchers and messages), subscribe to future updates.  <a href="class_u_stream_chat_client_component.html#a4d324df894080737f8e915db575fed6d">More...</a><br /></td></tr>
<tr class="separator:a4d324df894080737f8e915db575fed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f76b944317a89801ecef0c52ef7750b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a4f76b944317a89801ecef0c52ef7750b">QueryUsers</a> (TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_user_ref.html">FUserRef</a> &gt; &amp;)&gt; Callback, const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;Filter={}, const TArray&lt; <a class="el" href="struct_f_user_sort_option.html">FUserSortOption</a> &gt; &amp;Sort={}, bool bPresence=true, TOptional&lt; uint32 &gt; Limit={}, TOptional&lt; uint32 &gt; Offset={}) const</td></tr>
<tr class="memdesc:a4f76b944317a89801ecef0c52ef7750b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for users and see if they are online/offline.  <a href="class_u_stream_chat_client_component.html#a4f76b944317a89801ecef0c52ef7750b">More...</a><br /></td></tr>
<tr class="separator:a4f76b944317a89801ecef0c52ef7750b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a027a441d6ac2dcd7619f4f99a960f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a8a027a441d6ac2dcd7619f4f99a960f9">SearchMessages</a> (TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_message.html">FMessage</a> &gt; &amp;)&gt; Callback, const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;ChannelFilter={}, const TOptional&lt; FString &gt; &amp;<a class="el" href="group___stream_chat.html#gga5f415eaba7bb8ad8ae40f5b8b3eb69b5a66c1b4c7f3dc385b68a9fa903ccd016d">Query</a>={}, const TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; &amp;MessageFilter={}, const TArray&lt; <a class="el" href="struct_f_message_sort_option.html">FMessageSortOption</a> &gt; &amp;Sort={}, TOptional&lt; uint32 &gt; MessageLimit={}) const</td></tr>
<tr class="memdesc:a8a027a441d6ac2dcd7619f4f99a960f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search all messages A channel filter is required. All other parameters are optional, but a minimum of either a query or message filter is additionally required.  <a href="class_u_stream_chat_client_component.html#a8a027a441d6ac2dcd7619f4f99a960f9">More...</a><br /></td></tr>
<tr class="separator:a8a027a441d6ac2dcd7619f4f99a960f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6f9c8a21ee1d6b4b6e582f4364f645"><td class="memItemLeft" align="right" valign="top"><a id="afa6f9c8a21ee1d6b4b6e582f4364f645"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateMessage</b> (const FString &amp;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8fa490aa6e856ccf208a054389e47ce0d06">Id</a>, const FString &amp;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8fa9dffbf69ffba8bc38bc4e01abf4b1675">Text</a>) const</td></tr>
<tr class="separator:afa6f9c8a21ee1d6b4b6e582f4364f645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c66ae8547c8eed9286d33ac10d3381e"><td class="memItemLeft" align="right" valign="top"><a id="a7c66ae8547c8eed9286d33ac10d3381e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DeleteMessage</b> (const FString &amp;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8fa490aa6e856ccf208a054389e47ce0d06">Id</a>) const</td></tr>
<tr class="separator:a7c66ae8547c8eed9286d33ac10d3381e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8f4ebe58908f59fac7872026f37fef"><td class="memItemLeft" align="right" valign="top"><a id="a4f8f4ebe58908f59fac7872026f37fef"></a>
const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetChannels</b> () const</td></tr>
<tr class="separator:a4f8f4ebe58908f59fac7872026f37fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd4aeacd878fb2c6b3c5d4a9934922a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a6fd4aeacd878fb2c6b3c5d4a9934922a">ConnectUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const FString &amp;Token, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;OutUser)</td></tr>
<tr class="separator:a6fd4aeacd878fb2c6b3c5d4a9934922a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff32121d75eca129de69f76e351cc92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#acff32121d75eca129de69f76e351cc92">ConnectAnonymousUser</a> (const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;OutUser)</td></tr>
<tr class="separator:acff32121d75eca129de69f76e351cc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af908d5e4824f9feeb71f945b570f2d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#af908d5e4824f9feeb71f945b570f2d2f">ConnectGuestUser</a> (const <a class="el" href="struct_f_user.html">FUser</a> &amp;User, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;OutUser)</td></tr>
<tr class="separator:af908d5e4824f9feeb71f945b570f2d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a960c3c9631c36846e57bf5e183e0e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a6a960c3c9631c36846e57bf5e183e0e8">QueryChannels</a> (<a class="el" href="struct_f_filter.html">FFilter</a> Filter, const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;SortOptions, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;OutChannels, UPARAM(meta=(Bitmask, BitmaskEnum=<a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>)) const int32 Flags=3)</td></tr>
<tr class="separator:a6a960c3c9631c36846e57bf5e183e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78cae04fd73d3df82ef147487a5a71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#aa78cae04fd73d3df82ef147487a5a71c">WatchChannel</a> (const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;ChannelProperties, const UObject *WorldContextObject, FLatentActionInfo LatentInfo, <a class="el" href="class_u_chat_channel.html">UChatChannel</a> *&amp;OutChannel)</td></tr>
<tr class="separator:aa78cae04fd73d3df82ef147487a5a71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8faa7f538db03c650b73e9ac381eb15b"><td class="memTemplParams" colspan="2"><a id="a8faa7f538db03c650b73e9ac381eb15b"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:a8faa7f538db03c650b73e9ac381eb15b"><td class="memTemplItemLeft" align="right" valign="top">FDelegateHandle&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a8faa7f538db03c650b73e9ac381eb15b">On</a> (TEventDelegate&lt; TEvent &gt; Callback)</td></tr>
<tr class="memdesc:a8faa7f538db03c650b73e9ac381eb15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe to a client event using your own delegate object. <br /></td></tr>
<tr class="separator:a8faa7f538db03c650b73e9ac381eb15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03464a6c70a6848cff3e0744099a7a86"><td class="memTemplParams" colspan="2">template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a03464a6c70a6848cff3e0744099a7a86"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt; TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a03464a6c70a6848cff3e0744099a7a86">On</a> (UserClass *Obj, TEventDelegateUObjectMethodPtr&lt; TEvent, UserClass &gt; Method)</td></tr>
<tr class="separator:a03464a6c70a6848cff3e0744099a7a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c33fda79441595223429c1e769e320f"><td class="memTemplParams" colspan="2">template&lt;class TEvent , class UserClass &gt; </td></tr>
<tr class="memitem:a0c33fda79441595223429c1e769e320f"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt;!TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a0c33fda79441595223429c1e769e320f">On</a> (UserClass *Obj, TEventDelegateSpMethodPtr&lt; TEvent, UserClass &gt; Method)</td></tr>
<tr class="separator:a0c33fda79441595223429c1e769e320f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccfc8b8482dc78f95e963a5fedc5e12"><td class="memTemplParams" colspan="2">template&lt;class TEvent , typename FunctorType , typename... VarTypes&gt; </td></tr>
<tr class="memitem:a1ccfc8b8482dc78f95e963a5fedc5e12"><td class="memTemplItemLeft" align="right" valign="top">TEnableIf&lt; TIsInvocable&lt; FunctorType, const TEvent &amp;, VarTypes... &gt;::Value, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a1ccfc8b8482dc78f95e963a5fedc5e12">On</a> (FunctorType &amp;&amp;Functor, VarTypes... Vars)</td></tr>
<tr class="separator:a1ccfc8b8482dc78f95e963a5fedc5e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memTemplParams" colspan="2"><a id="aef6c08642d4ed10c3c0de4dfba355e55"></a>
template&lt;class TEvent &gt; </td></tr>
<tr class="memitem:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Unsubscribe</b> (FDelegateHandle) const</td></tr>
<tr class="separator:aef6c08642d4ed10c3c0de4dfba355e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8f1611110a0cfab519e76f15b13cdb66"><td class="memItemLeft" align="right" valign="top"><a id="a8f1611110a0cfab519e76f15b13cdb66"></a>
static FString&#160;</td><td class="memItemRight" valign="bottom"><b>DevToken</b> (const FString &amp;<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8fa4733e94f511132be01e92cc23c017d16">UserId</a>)</td></tr>
<tr class="separator:a8f1611110a0cfab519e76f15b13cdb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af011c46e90b9370774d1339f605463a6"><td class="memItemLeft" align="right" valign="top"><a id="af011c46e90b9370774d1339f605463a6"></a>
FString&#160;</td><td class="memItemRight" valign="bottom"><b>ApiKey</b></td></tr>
<tr class="separator:af011c46e90b9370774d1339f605463a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="memItemLeft" align="right" valign="top"><a id="a4782f198e76dd5dbd7ab4300eacfc9e8"></a>
FChannelsUpdatedDelegate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_stream_chat_client_component.html#a4782f198e76dd5dbd7ab4300eacfc9e8">ChannelsUpdated</a></td></tr>
<tr class="memdesc:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fired when any of the channels we have locally change. <br /></td></tr>
<tr class="separator:a4782f198e76dd5dbd7ab4300eacfc9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A component which allows for connecting to the Stream Chat API. Should be added to a client-side actor, e.g. HUD. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acff32121d75eca129de69f76e351cc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff32121d75eca129de69f76e351cc92">&#9670;&nbsp;</a></span>ConnectAnonymousUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectAnonymousUser </td>
          <td>(</td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a connection to the API anonymously </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutUser</td><td>Anonymous user info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a137af7f2bf4a48b1a0c1e75e04d2af3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137af7f2bf4a48b1a0c1e75e04d2af3c">&#9670;&nbsp;</a></span>ConnectAnonymousUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectAnonymousUser </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API anonymously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anonymous user info </dd></dl>

</div>
</div>
<a id="af908d5e4824f9feeb71f945b570f2d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af908d5e4824f9feeb71f945b570f2d2f">&#9670;&nbsp;</a></span>ConnectGuestUser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectGuestUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a connection to the API by creating a guest account </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">OutUser</td><td>Guest user info </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2bbdb1a7df673dbaecfd8e8c28d6fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2bbdb1a7df673dbaecfd8e8c28d6fc3">&#9670;&nbsp;</a></span>ConnectGuestUser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectGuestUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API by creating a guest account. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Anonymous user info </dd></dl>

</div>
</div>
<a id="a6fd4aeacd878fb2c6b3c5d4a9934922a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd4aeacd878fb2c6b3c5d4a9934922a">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>Token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;&#160;</td>
          <td class="paramname"><em>OutUser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a connection to the API for the given user and credentials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Token</td><td>A JWT token for the given user </td></tr>
    <tr><td class="paramname">OutUser</td><td>Latest info of the logged in user </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6229a8fcf989852a5abc72c04779b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6229a8fcf989852a5abc72c04779b58">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FString &amp;&#160;</td>
          <td class="paramname"><em>Token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API for the given user and credentials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">Token</td><td>A JWT token for the given user </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Latest info if the logged in user </dd></dl>

</div>
</div>
<a id="a772775375b6df48ed9280caa356dea13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772775375b6df48ed9280caa356dea13">&#9670;&nbsp;</a></span>ConnectUser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::ConnectUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_user.html">FUser</a> &amp;&#160;</td>
          <td class="paramname"><em>User</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TUniquePtr&lt; ITokenProvider &gt;&#160;</td>
          <td class="paramname"><em>TokenProvider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(const <a class="el" href="struct_f_user_ref.html">FUserRef</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a connection to the API for the given user and using a custom token provider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">User</td><td>Generally only the user id is required </td></tr>
    <tr><td class="paramname">TokenProvider</td><td>Can be used to asynchronously generate tokens from your own backend </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Latest info if the logged in user </dd></dl>

</div>
</div>
<a id="a2a8eced83c1c5533f264b8e1c7b5c15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8eced83c1c5533f264b8e1c7b5c15e">&#9670;&nbsp;</a></span>CreateChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::CreateChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to create </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<a id="a1ccfc8b8482dc78f95e963a5fedc5e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccfc8b8482dc78f95e963a5fedc5e12">&#9670;&nbsp;</a></span>On() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , typename FunctorType , typename... VarTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt; TIsInvocable&lt; FunctorType, const TEvent &amp;, VarTypes... &gt;::Value, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">FunctorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>Functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VarTypes...&#160;</td>
          <td class="paramname"><em>Vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe to a client event using a C++ lambda </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Functor</td><td>Lambda to execute when event occurs. Should have signature similar to: [](const TEvent&amp; Event){} </td></tr>
    <tr><td class="paramname">Vars</td><td>Additional variables to pass to the lambda </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="a0c33fda79441595223429c1e769e320f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c33fda79441595223429c1e769e320f">&#9670;&nbsp;</a></span>On() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , class UserClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt;!TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">UserClass *&#160;</td>
          <td class="paramname"><em>Obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEventDelegateSpMethodPtr&lt; TEvent, UserClass &gt;&#160;</td>
          <td class="paramname"><em>Method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe to a client event using a shared pointer-based (fast, not thread-safe) member function delegate. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td>Object with given method </td></tr>
    <tr><td class="paramname">Method</td><td>Method to call when event occurs. Should have signature: void OnMyEvent(const TEvent&amp; Event) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="a03464a6c70a6848cff3e0744099a7a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03464a6c70a6848cff3e0744099a7a86">&#9670;&nbsp;</a></span>On() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TEvent , class UserClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TEnableIf&lt; TIsDerivedFrom&lt; UserClass, UObject &gt;::IsDerived, FDelegateHandle &gt;::<a class="el" href="group___stream_chat.html#gga3f9dd725081330daf92bbd44f5084e8faa1fa27779242b4902f7ae3bdd5c6d508">Type</a> UStreamChatClientComponent::On </td>
          <td>(</td>
          <td class="paramtype">UserClass *&#160;</td>
          <td class="paramname"><em>Obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEventDelegateUObjectMethodPtr&lt; TEvent, UserClass &gt;&#160;</td>
          <td class="paramname"><em>Method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe to a client event using a UObject-based member function delegate. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TEvent</td><td>Event type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Obj</td><td>UObject with given method </td></tr>
    <tr><td class="paramname">Method</td><td>Method to call when event occurs. Should have signature: void OnMyEvent(const TEvent&amp; Event) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle which can be used to unsubscribe from the event </dd></dl>

</div>
</div>
<a id="a4d324df894080737f8e915db575fed6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d324df894080737f8e915db575fed6d">&#9670;&nbsp;</a></span>QueryChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>&#160;</td>
          <td class="paramname"><em>Flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions). Includes options to get data about the channel (including members, watchers and messages), subscribe to future updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to query </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<a id="a6a960c3c9631c36846e57bf5e183e0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a960c3c9631c36846e57bf5e183e0e8">&#9670;&nbsp;</a></span>QueryChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_filter.html">FFilter</a>&#160;</td>
          <td class="paramname"><em>Filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>OutChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UPARAM(meta=(Bitmask, BitmaskEnum=<a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>)) const int32&#160;</td>
          <td class="paramname"><em>Flags</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the API for all channels which match the given filter. Will also automatically watch all channels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Filter</td><td>The query filters to use. You can query on any of the custom fields you've defined on the Channel. As a minimum, the filter should be something like: { members: { $in: [userID] } } </td></tr>
    <tr><td class="paramname">SortOptions</td><td>The sorting used for the channels matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">OutChannels</td><td>An array of channel objects which can be used to interact with the channels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70109502de94907851f19ae97fe02a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70109502de94907851f19ae97fe02a8b">&#9670;&nbsp;</a></span>QueryChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryChannels </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="class_u_chat_channel.html">UChatChannel</a> * &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt;&#160;</td>
          <td class="paramname"><em>Filter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_channel_sort_option.html">FChannelSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SortOptions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___stream_chat_api.html#ga683630d96445bae6259c39daebb90898">EChannelFlags</a>&#160;</td>
          <td class="paramname"><em>Flags</em> = <code><a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898a46a2a41cc6e552044816a2d04634545d">EChannelFlags::State</a>&#160;|&#160;<a class="el" href="group___stream_chat_api.html#gga683630d96445bae6259c39daebb90898af20658650d987d31063b593c05980397">EChannelFlags::Watch</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_pagination_options.html">FChannelPaginationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>PaginationOptions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the API for all channels which match the given filter. Will also automatically watch all channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
    <tr><td class="paramname">Filter</td><td>The query filters to use. You can query on any of the custom fields you've defined on the Channel. As a minimum, the filter should be something like: { members: { $in: [userID] } } </td></tr>
    <tr><td class="paramname">SortOptions</td><td>The sorting used for the channels matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">Flags</td><td>Get state, get presence and/or watch </td></tr>
    <tr><td class="paramname">PaginationOptions</td><td>Pagination offset and limit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of channel objects which can be used to interact with the channels </dd></dl>

</div>
</div>
<a id="a4f76b944317a89801ecef0c52ef7750b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f76b944317a89801ecef0c52ef7750b">&#9670;&nbsp;</a></span>QueryUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::QueryUsers </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_user_ref.html">FUserRef</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>Filter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_user_sort_option.html">FUserSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sort</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPresence</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOptional&lt; uint32 &gt;&#160;</td>
          <td class="paramname"><em>Limit</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOptional&lt; uint32 &gt;&#160;</td>
          <td class="paramname"><em>Offset</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for users and see if they are online/offline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bPresence</td><td>Get updates when the user goes offline/online </td></tr>
    <tr><td class="paramname">Filter</td><td>Conditions to use to filter the users, </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://getstream.io/chat/docs/unreal/query_users">https://getstream.io/chat/docs/unreal/query_users</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Sort</td><td>The sorting used for the users matching the filters. Sorting is based on field and direction, multiple sorting options can be provided. </td></tr>
    <tr><td class="paramname">Limit</td><td>The number of users to return </td></tr>
    <tr><td class="paramname">Offset</td><td>The pagination offset </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when response is received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a027a441d6ac2dcd7619f4f99a960f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a027a441d6ac2dcd7619f4f99a960f9">&#9670;&nbsp;</a></span>SearchMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::SearchMessages </td>
          <td>(</td>
          <td class="paramtype">TFunction&lt; void(const TArray&lt; <a class="el" href="struct_f_message.html">FMessage</a> &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_f_filter.html">FFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelFilter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; FString &gt; &amp;&#160;</td>
          <td class="paramname"><em>Query</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TOptional&lt; <a class="el" href="struct_f_filter.html">FFilter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>MessageFilter</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TArray&lt; <a class="el" href="struct_f_message_sort_option.html">FMessageSortOption</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Sort</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOptional&lt; uint32 &gt;&#160;</td>
          <td class="paramname"><em>MessageLimit</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search all messages A channel filter is required. All other parameters are optional, but a minimum of either a query or message filter is additionally required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Callback</td><td>Called when response is received </td></tr>
    <tr><td class="paramname">Query</td><td>Search phrase </td></tr>
    <tr><td class="paramname">ChannelFilter</td><td>Channel filter conditions </td></tr>
    <tr><td class="paramname">MessageFilter</td><td>Message filter conditions </td></tr>
    <tr><td class="paramname">Sort</td><td>Sort parameters. Cannot be used with non-zero offset. </td></tr>
    <tr><td class="paramname">MessageLimit</td><td>Number of messages to return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa78cae04fd73d3df82ef147487a5a71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78cae04fd73d3df82ef147487a5a71c">&#9670;&nbsp;</a></span>WatchChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::WatchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UObject *&#160;</td>
          <td class="paramname"><em>WorldContextObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLatentActionInfo&#160;</td>
          <td class="paramname"><em>LatentInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_u_chat_channel.html">UChatChannel</a> *&amp;&#160;</td>
          <td class="paramname"><em>OutChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to watch </td></tr>
    <tr><td class="paramname">OutChannel</td><td>Object which can be used to interact with the channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a705b3527835b5c7354ee5eeb8859320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705b3527835b5c7354ee5eeb8859320a">&#9670;&nbsp;</a></span>WatchChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UStreamChatClientComponent::WatchChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_f_channel_properties.html">FChannelProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>ChannelProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunction&lt; void(<a class="el" href="class_u_chat_channel.html">UChatChannel</a> *)&gt;&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a channel if it does not exist yet (if this user has the right permissions), get data about the channel (including members, watchers and messages) and subscribe to future updates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ChannelProperties</td><td>Properties of the channel to watch </td></tr>
    <tr><td class="paramname">Callback</td><td>Called when a response is received from the API </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A channel object which can be used to interact with the channel </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/StreamChat/Public/<a class="el" href="_stream_chat_client_component_8h_source.html">StreamChatClientComponent.h</a></li>
<li>Source/StreamChat/Private/StreamChatClientComponent.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_u_stream_chat_client_component.html">UStreamChatClientComponent</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
